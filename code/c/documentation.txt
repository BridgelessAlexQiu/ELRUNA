map<int, list<int>> g1_neighbor_map / g2_neighbor_map;

map<string, int> g1_name_id_mapping / g2_name_id_mapping;

int** g1_neighbor_sequence / g2_neighbor_sequence = new int*[g1_size / g2_size];

int* g1_degree_sequence / g2_degree_sequence = new int[g1_size / g2_size];

double** S_even = new double*[g1_size];

double** S_odd = new double*[g1_size];

int mapping[g1_size];

map<int, int> inverse_mapping; 

map<int, int> g2_induced_degree_sequence;

SparseMatrix<int> C / D / E (g1_size / g2_size / g3_size); 
SparseMatrix<double> 
SparseMatrix<double> initial_violation (g3_size, 1);
SparseMatrix<double> R (g3_size, 1); 
--------------------------------------------------------------------------------------------------------------

int g1_selected / g2_selected[g1_size / g2_size] = {0}; (stack)

double g1_node_coverage_percentage / g2_node_coverage_percentage [g1_size / g2_size][max_iter]; (stack)

double b_g1 / b_g2 [g1_size / g2_size]; (stack)

